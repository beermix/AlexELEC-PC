diff -Naurp vdr-2.2.0/keys.c vdr-2.2.0-patch/keys.c
--- vdr-2.2.0/keys.c	2012-12-04 14:52:52.000000000 +0200
+++ vdr-2.2.0-patch/keys.c	2016-08-24 16:32:18.000000000 +0300
@@ -43,6 +43,8 @@ static tKey keyTable[] = { // "Up" and "
                     { kNext,          trNOOP("Key$Next")        },
                     { kPrev,          trNOOP("Key$Prev")        },
                     { kPower,         trNOOP("Key$Power")       },
+                    { kExit,          trNOOP("Key$Exit")        },
+                    { kSleep,         trNOOP("Key$Sleep")       },
                     { kChanUp,        trNOOP("Key$Channel+")    },
                     { kChanDn,        trNOOP("Key$Channel-")    },
                     { kChanPrev,      trNOOP("Key$PrevChannel") },
diff -Naurp vdr-2.2.0/keys.h vdr-2.2.0-patch/keys.h
--- vdr-2.2.0/keys.h	2015-01-27 12:45:18.000000000 +0200
+++ vdr-2.2.0-patch/keys.h	2016-08-24 16:32:18.000000000 +0300
@@ -37,6 +37,8 @@ enum eKeys { // "Up" and "Down" must be
              kNext,
              kPrev,
              kPower,
+             kExit,
+             kSleep,
              kChanUp,
              kChanDn,
              kChanPrev,
diff -Naurp vdr-2.2.0/menu.c vdr-2.2.0-patch/menu.c
--- vdr-2.2.0/menu.c	2016-08-24 17:16:53.000000000 +0300
+++ vdr-2.2.0-patch/menu.c	2016-08-24 17:15:12.000000000 +0300
@@ -33,6 +33,9 @@
 #include "transfer.h"
 #include "videodir.h"
 
+#include <fstream>
+#include <algorithm>
+
 #include "remotetimers.h"
 
 #define MAXWAIT4EPGINFO   3 // seconds
@@ -2010,28 +2013,57 @@ eOSState cMenuCommands::Execute(void)
               cmdbuf = cString::sprintf("%s %s", *command, *parameters);
            const char *cmd = *cmdbuf ? *cmdbuf : *command;
            dsyslog("executing command '%s'", cmd);
-           cPipe p;
-           if (p.Open(cmd, "r")) {
-              int l = 0;
-              int c;
-              while ((c = fgetc(p)) != EOF) {
-                    if (l % 20 == 0) {
-                       if (char *NewBuffer = (char *)realloc(result, l + 21))
-                          result = NewBuffer;
-                       else {
-                          esyslog("ERROR: out of memory");
-                          break;
-                          }
-                       }
-                    result[l++] = char(c);
-                    }
-              if (result)
-                 result[l] = 0;
-              p.Close();
-              }
+           if (strcmp(cmd, "exit") == 0)
+           {
+               std::ifstream isBackVDR, isBackTVH;
+               isBackVDR.open("/storage/.cache/services/vdr-backend.conf");
+               isBackTVH.open("/storage/.cache/services/tvheadend.conf");
+               if (!isBackVDR.good() && !isBackTVH.good())
+               {
+                  cDevice::PrimaryDevice()->ToggleMute();
+                  esyslog("VDR frontend fast stopping...");
+                  remove("/var/lock/start.vdr");
+                  system("touch /var/lock/start.kodi");
+                  SystemExec("systemctl start kodi.service", true);
+                  system("touch /var/lock/exit-fast.vdr");
+               }
+               else
+                  esyslog("VDR frontend normal stopping...");
+               isBackVDR.close();
+               isBackTVH.close();
+               ShutdownHandler.Exit(0);
+           }
+           else if (strcmp(cmd, "sleep") == 0)
+               ShutdownHandler.Exit(97);
+           else if (strcmp(cmd, "sysreboot") == 0)
+               ShutdownHandler.Exit(98);
+           else if (strcmp(cmd, "syspower") == 0)
+               ShutdownHandler.Exit(99);
            else
-              esyslog("ERROR: can't open pipe for command '%s'", cmd);
-           Skins.Message(mtStatus, NULL);
+           {
+             cPipe p;
+             if (p.Open(cmd, "r")) {
+                int l = 0;
+                int c;
+                while ((c = fgetc(p)) != EOF) {
+                      if (l % 20 == 0) {
+                         if (char *NewBuffer = (char *)realloc(result, l + 21))
+                            result = NewBuffer;
+                         else {
+                            esyslog("ERROR: out of memory");
+                            break;
+                            }
+                         }
+                      result[l++] = char(c);
+                      }
+                if (result)
+                   result[l] = 0;
+                p.Close();
+                }
+             else
+                esyslog("ERROR: can't open pipe for command '%s'", cmd);
+             Skins.Message(mtStatus, NULL);
+           }
            if (result)
               return AddSubMenu(new cMenuText(title, result, fontFix));
            return osEnd;
diff -Naurp vdr-2.2.0/po/ru_RU.po vdr-2.2.0-patch/po/ru_RU.po
--- vdr-2.2.0/po/ru_RU.po	2016-08-24 17:16:53.000000000 +0300
+++ vdr-2.2.0-patch/po/ru_RU.po	2016-08-24 16:32:18.000000000 +0300
@@ -1537,12 +1537,24 @@ msgstr "Остановить live video?"
 msgid "Recording started"
 msgstr "Запись начата"
 
-msgid "VDR will shut down later - press Power to force"
-msgstr "VDR выключится позже - нажмите Power для ускорения"
+msgid "MediaCenter will shut down later - press Power to force"
+msgstr "Медиацентр выключится позже - нажмите Power для ускорения"
+
+msgid "VDR will close later - press Exit to force"
+msgstr "VDR будет закрыт позже - нажмите Exit для ускорения"
+
+msgid "MediaCenter will sleep later - press Sleep to force"
+msgstr "Медиацентр будет переведен в сон позже - нажмите Sleep для ускорения"
 
 msgid "Press any key to cancel shutdown"
 msgstr "Нажмите любую кнопку чтобы отменить выключение."
 
+msgid "Press any key to cancel exit"
+msgstr "Нажмите любую кнопку чтобы отменить переключение в KODI."
+
+msgid "Press any key to cancel sleep"
+msgstr "Нажмите любую кнопку чтобы отменить режим сна."
+
 msgid "Switching primary DVB..."
 msgstr "Смена основного DVB-устройства..."
 
diff -Naurp vdr-2.2.0/shutdown.c vdr-2.2.0-patch/shutdown.c
--- vdr-2.2.0/shutdown.c	2013-10-02 12:02:01.000000000 +0300
+++ vdr-2.2.0-patch/shutdown.c	2016-08-24 16:15:47.000000000 +0300
@@ -130,9 +130,9 @@ void cShutdownHandler::SetShutdownComman
 void cShutdownHandler::CallShutdownCommand(time_t WakeupTime, int Channel, const char *File, bool UserShutdown)
 {
   time_t Delta = WakeupTime ? WakeupTime - time(NULL) : 0;
-  cString cmd = cString::sprintf("%s %ld %ld %d \"%s\" %d", shutdownCommand, WakeupTime, Delta, Channel, *strescape(File, "\\\"$"), UserShutdown);
+  cString cmd = cString::sprintf("PowerOFF: %ld %ld %d \"%s\" %d", WakeupTime, Delta, Channel, *strescape(File, "\\\"$"), UserShutdown);
   isyslog("executing '%s'", *cmd);
-  int Status = SystemExec(cmd, true);
+  int Status = SystemExec("systemctl poweroff", true);
   if (!WIFEXITED(Status) || WEXITSTATUS(Status))
      esyslog("SystemExec() failed with status %d", Status);
   else {
@@ -162,11 +162,6 @@ bool cShutdownHandler::ConfirmShutdown(b
   if (!Interactive && !cRemote::Enabled())
      return false;
 
-  if (!shutdownCommand) {
-     if (Interactive)
-        Skins.Message(mtError, tr("Can't shutdown - option '-s' not given!"));
-     return false;
-     }
   if (RecordingsHandler.Active()) {
      if (!Interactive || !Interface->Confirm(tr("Editing - shut down anyway?")))
         return false;
diff -Naurp vdr-2.2.0/vdr.c vdr-2.2.0-patch/vdr.c
--- vdr-2.2.0/vdr.c	2016-08-24 17:16:53.000000000 +0300
+++ vdr-2.2.0-patch/vdr.c	2016-08-24 17:28:18.000000000 +0300
@@ -72,12 +72,15 @@
 #include "videodir.h"
 #include "status.h"
 
+#include <fstream>
+#include <algorithm>
+
 #define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
 #define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
 #define SHUTDOWNWAIT         300 // seconds to wait in user prompt before automatic shutdown
 #define SHUTDOWNRETRY        360 // seconds before trying again to shut down
-#define SHUTDOWNFORCEPROMPT    5 // seconds to wait in user prompt to allow forcing shutdown
-#define SHUTDOWNCANCELPROMPT   5 // seconds to wait in user prompt to allow canceling shutdown
+#define SHUTDOWNFORCEPROMPT    3 // seconds to wait in user prompt to allow forcing shutdown
+#define SHUTDOWNCANCELPROMPT   3 // seconds to wait in user prompt to allow canceling shutdown
 #define RESTARTCANCELPROMPT    5 // seconds to wait in user prompt before restarting on SIGHUP
 #define MANUALSTART          600 // seconds the next timer must be in the future to assume manual start
 #define CHANNELSAVEDELTA     120 // seconds before saving channels.conf after automatic modifications
@@ -93,6 +96,8 @@
 
 static int LastSignal = 0;
 
+std::ifstream isVDR, isTVH, isFast;
+
 static bool SetUser(const char *UserName, bool UserDump)
 {
   if (UserName) {
@@ -1262,7 +1267,7 @@ int main(int argc, char *argv[])
                isyslog("Power button pressed");
                DELETE_MENU;
                // Check for activity, request power button again if active:
-               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("VDR will shut down later - press Power to force"), SHUTDOWNFORCEPROMPT) != kPower) {
+               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("MediaCenter will shut down later - press Power to force"), SHUTDOWNFORCEPROMPT) != kPower) {
                   // Not pressed power - set VDR to be non-interactive and power down later:
                   ShutdownHandler.SetUserInactive();
                   break;
@@ -1284,6 +1289,75 @@ int main(int argc, char *argv[])
                // Do not attempt to automatically shut down for a while:
                ShutdownHandler.SetRetry(SHUTDOWNRETRY);
                break;
+          // Exit to KODI:
+          case kExit:
+               isyslog("Exit button pressed");
+               DELETE_MENU;
+               // Check for activity, request exit button again if active:
+               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("VDR will close later - press Exit to force"), SHUTDOWNFORCEPROMPT) != kExit) {
+                  // Not pressed exit - set VDR to be non-interactive and exit later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // No activity or exit button pressed twice - ask for confirmation:
+               if (!ShutdownHandler.ConfirmShutdown(true)) {
+                  // Non-confirmed background activity - set VDR to be non-interactive and exit down later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // Ask the final question:
+               if (!Interface->Confirm(tr("Press any key to cancel exit"), SHUTDOWNCANCELPROMPT, true))
+                  // If final question was canceled, continue to be active:
+                  break;
+               // Ok, now call the exit script:
+               isVDR.open("/storage/.cache/services/vdr-backend.conf");
+               isTVH.open("/storage/.cache/services/tvheadend.conf");
+               if (!isVDR.good() && !isTVH.good())
+               {
+                  cDevice::PrimaryDevice()->ToggleMute();
+                  esyslog("VDR frontend fast stopping...");
+                  remove("/var/lock/start.vdr");
+                  system("touch /var/lock/start.kodi");
+                  SystemExec("systemctl start kodi.service", true);
+                  system("touch /var/lock/exit-fast.vdr");
+               }
+               else
+                  esyslog("VDR frontend normal stopping...");
+               isVDR.close();
+               isTVH.close();
+               EXIT(0);
+               // Set VDR to be non-interactive and exit down again later:
+               ShutdownHandler.SetUserInactive();
+               // Do not attempt to automatically exit for a while:
+               ShutdownHandler.SetRetry(SHUTDOWNRETRY);
+               break;
+          // Sleep:
+          case kSleep:
+               isyslog("Sleep button pressed");
+               DELETE_MENU;
+               // Check for activity, request exit button again if active:
+               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("MediaCenter will sleep later - press Sleep to force"), SHUTDOWNFORCEPROMPT) != kSleep) {
+                  // Not pressed sleep - set VDR to be non-interactive and sleep later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // No activity or sleep button pressed twice - ask for confirmation:
+               if (!ShutdownHandler.ConfirmShutdown(true)) {
+                  // Non-confirmed background activity - set VDR to be non-interactive and sleep down later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // Ask sleep question:
+               if (!Interface->Confirm(tr("Press any key to cancel sleep"), SHUTDOWNCANCELPROMPT, true))
+                  // If final question was canceled, continue to be active:
+                  break;
+               // Ok, now call the sleep script:
+               EXIT(97);
+               // Set VDR to be non-interactive and sleep again later:
+               ShutdownHandler.SetUserInactive();
+               // Do not attempt to automatically sleep for a while:
+               ShutdownHandler.SetRetry(SHUTDOWNRETRY);
+               break;
           default: break;
           }
         Interact = Menu ? Menu : cControl::Control(); // might have been closed in the mean time
@@ -1510,5 +1584,35 @@ Exit:
      closelog();
   if (HasStdin)
      tcsetattr(STDIN_FILENO, TCSANOW, &savedTm);
+
+  // EXIT code
+  isFast.open("/var/lock/exit-fast.vdr");
+  switch(ShutdownHandler.GetExitCode()) {
+     case 0: // Exit to Kodi
+         if (isFast.good())
+         {
+            remove("/var/lock/exit-fast.vdr");
+            esyslog("VDR frontend fast exit!!!");
+         }
+         else
+         {
+            esyslog("VDR frontend normal exit!!!");
+            remove("/var/lock/start.vdr");
+            system("touch /var/lock/start.kodi");
+            SystemExec("systemctl start kodi.service", true);
+         }
+         isFast.close();
+         break;
+     case 97: // Sleep
+         SystemExec("systemctl suspend", true);
+         break;
+     case 98: // Reboot
+         SystemExec("systemctl reboot", true);
+         break;
+     case 99: // Shutdown
+         SystemExec("systemctl poweroff", true);
+         break;
+    }
+
   return ShutdownHandler.GetExitCode();
 }
